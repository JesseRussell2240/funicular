# funicular
Selfdriving R-pi code


**Establishing SSH From Laptop To Rpi**
1. Get IP of RPI should be like 192.168.#.###

2. Enable SSH on the Rpi
   -Open Terminal on the Rpi and type **"sudo raspi-config"** in the configuration menu go to "3. Interface      Options" and enable SSH
   -In CMD on laptop type "ssh rpi@rpi ip address found in step one" Ex. **"ssh rpi@192.168.#.###"**
   -If prompted with "WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED" it means you have an existing key under that IP address, type "ssh-keygen -R ip address found in step one" Ex. **"ssh-keygen -R 192.168.#.###"** This will clear that key
   -Now try **"ssh rpi@192.168.#.###"** again, when prompted to continue connected type **"yes"**
   -When prompted for the password, enter the Rpis password you set when configuring Ex **"rpi_password"**
   -SSH should now be established

**Installing OpenCV in Terminal on Rpi**
1. In Terminal **"pip install opencv-python --break-system-package"**

**Installing PiCamera in Terminal on Rpi**
1. In Terminal **"pip install picamera --break-system-package"**


**Camera Unit Testing instructions**
**this needs confirming**
1. pip install picamera opencv-python

2. run unit testing code - python test_camera_module.py
After this is running you should see a window with a live camera feed.Type 'q' to exit.


**Preception unit testing instructions**
**This needs confirming**
1. pip install opencv-python numpy

2. run unit testing code - python test_perception_module.py
preception also has a main to test preception and cameras joint integration. Ensure camera module is successfull prior to moving on to preception.

This is to install flask and other for R-Pi server hosting website to control and recive video remotly
pip install flask flask-socketio opencv-python


ENSURE FLASK SERVER IS NOT IN DEBUG OR LIVESTREAM WILL NOT WORK

**Funicular Readme**

**------------------------------Python---------------------------------**

**App.py**
App.py enables the flask-based web server and is responsible for all the data displayed on the web server and the controls within the web server. App.py sets up the flask server, enables and handles the frames of the Module 3 Wide PiCam (dependent on Autonomous or Manual Mode), enables, reads and graphs the BNO08X 9-DOF sensor data via I2C, and handles the flask routes for the webserver (landing_page, auto_mode, manual_mode, 3d_model, live_video & graphs)


**Machine Learning**
For our ML model, we started by taking 100s of photos of our cones in various settings, configurations, and lighting, as well as some photos without cones. Once we had roughly 250 photos, we uploaded them to Roboflow (https://roboflow.com/), where we created our object class, cones, and manually selected the pixels containing cones. Once this was done, we used Roboflow to generate copies of each photo rotated, flipped, greyscales and inverted, bringing our total photos to about 1600. Once completed, we downloaded our dataset and yaml file. With our yaml created file, we then used the YOLO model 8 in Python to train on our dataset running 50 epochs, which took roughly 2 days. Once this was completed, we received our best.pt file. Follow this tutorial to convert the .pt to a .hef and run it on Rpiâ€™s Hailo Modules. https://www.youtube.com/watch?v=7pgSFgqo8gY

**-----------------------------Embedded--------------------------------**

**UART3.c**
Sets up UART interface on USART3 for receiving motor control commands from an external Raspberry Pi. It handles the reception of direction, duty cycle, and turning values, parses them, and adjusts motor behaviour accordingly. The code includes an interrupt-driven approach for receiving data and sending responses back, allowing for continuous operation with real-time motor adjustments.

**DriveMotor_Breifing.c**
The code configures and controls drive motors by setting up GPIO pins and timers to manage motor speed and direction. It uses PWM signals generated by Timer 8 for precise speed control and toggles GPIO pins for motor direction (forward, backward, or stop). The code provides functions to adjust both the speed (duty cycle) and direction of the turning and rear motors, allowing for real-time motor control in a robotic or motorized system.

**LimitSwitch.c**
The code initializes and configures two limit switches (we run in series to PC5) to pins PC5 and PC6 of the STM32 microcontroller. The code triggers interrupts on the rising edge of the signals from these limit switches. When an interrupt is detected, the interrupt handler stops the turning motor (via the SetMotor function) and sets a flag indicating that a limit switch has been triggered. The interrupt flags are then cleared to allow further interrupts to be processed.

**Homing.c**
The code implements a homing function for the turning motor using the limit switches and encoder to find the midpoint between two limit positions. It moves the motor left until the first limit switch is triggered, the encoder is reset, and the motor is reversed right to move towards the second limit switch. Once triggered, the motor is stopped, and the encoder value is recorded as the full turn value. The motor is then moved back toward the first limit switch, which continues until it reaches the midpoint of the full turn based on the encoder value. Once the midpoint is reached, the motor is stopped. The homing process ensures precise positioning with the help of the limit switches and encoder feedback.

**Encoder.c**
The code initializes and configures the encoder interface using the TIM2 peripheral for motor pulse tracking. It enables clocks for the necessary GPIO ports and configures PA0 and PA1 as alternate function pins for TIM2 channels. TIM2 is set to encoder mode, which counts rising and falling edges from the input channels (CH1 and CH2). The encoder data is tracked through the TIM2 counter, which increments or decrements based on the motor's rotation direction. The encoder interface provides real-time position feedback, allowing motor position tracking.

**Pinouts**
**Motors**
PC2: Turning Motor Forward direction control (+ terminal)
PC3: Turning Motor Reverse direction control (- terminal)
PC10: Turning Motor PWM for speed control
PB12: Rear Left Motor Forward direction control (+ terminal)
PC4: Rear Left Motor Reverse direction control (- terminal)
PC11: Rear Left Motor PWM for speed control
PC1: Rear Right Motor Forward direction control (+ terminal)
PC0: Rear Right Motor Reverse direction control (- terminal)
PC12: Rear Right Motor PWM for speed control

**Limit Switches**
PC5: Left & right limit switch (wired in series) interrupts

**Encoder**
PA0: Encoder Channel 1 Pulse Input
PA1 Encoder Channel 2 Pulse Input

**UART**
PB10: UART Transmit
PB11: UART Receive



**----------------------------Bill of Materials--------------------------**

**Raspberry Pi** (Tested on 8gb Rpi 5) https://www.pishop.ca/product/raspberry-pi-5-8gb/ 

**Raspberry Pi Ai Hat** https://www.pishop.ca/product/raspberry-pi-ai-hat-13-tops/ 

**Module 3 Wide PiCam** https://www.pishop.ca/product/raspberry-pi-camera-module-3-wide/

**BNO08X 9-DOF Sensor** https://www.adafruit.com/product/4754

**STM32F303RE** https://www.digikey.com/en/products/detail/stmicroelectronics/NUCLEO-F303RE/5052640 

**Quadrate Encoder Motor** https://www.amazon.ca/CHF-GM12-N20VA-Encoder-Reducer-Carbon-Popular/dp/B0DCRHDT71?th=1

**TT Motors** (Can buy from various sites, usually some good bundles on Amazon)

**Wheels & Tires** https://www.amazon.ca/SD-Tires-Off-Road-Wheel-Spokes/dp/B01DU1Q2Z2/ref=sr_1_11?crid=2I0K98L5BNCPU&dib=eyJ2IjoiMSJ9.cI6UmUyBRTIb6onZqANyJCB5GJu29HRcJqFFRgNGpl9MEFazOgidj2WoTJfcIKmJ6C4-n4sr1HgdO--VB0Fr5weXMLL_IUjAN58hv3SpvRIBoMx7K9QRsGwaciAwpsnwOWLM0uJSVsFw63VtnuHNZDHXElkr3HKhT2FJDoaWSCIqNgr1C1AIW5w8wSTBOuiKZaU9MLPBhtQIkVzc8JrsT8t3ZyeOtoh5w_CSmqbLdX5HbH1tSobqfiGQKl0RxVjJtXkQRYvlK9oNoTBKPsGCPVrTqJK1jTYkA114B9wv5aw.xhiF6mO44XExIxRyNs2yGgCopGQh5owXqnN7ELW8kSM&dib_tag=se&keywords=rc%2Bwheels&qid=1732571605&sprefix=rc%2Bwheels%2Caps%2C95&sr=8-11&th=1

**Limit Switches** (Any normally open snap-action limit switches will do)

**Battery** (Any battery able to supply ~5A will do) 

**Voltage Regulators** (Any voltage regular capable of doing the supplied battery voltage down to 5V for the Rpi and 10V for the TT motors will do, we used) https://www.amazon.ca/dp/B076H3XHXP/ref=sspa_dk_detail_3?pd_rd_i=B07T5X5LSH&pd_rd_w=ZvJmk&content-id=amzn1.sym.516c2169-755e-413a-a38a-68230f4ab66f&pf_rd_p=516c2169-755e-413a-a38a-68230f4ab66f&pf_rd_r=5SBS1FXA4XQXVDRSESP9&pd_rd_wg=6ueQo&pd_rd_r=504ae8bc-6851-47c6-8ca1-c492434739b6&s=industrial&sp_csd=d2lkZ2V0TmFtZT1zcF9kZXRhaWw&th=1 



**--------------------------------------------------------------------------------------------------------------------------<br>
-----------------------------------------------------Funicular By-------------------------------------------------------<br>
----------------------------------------------------Hayden & Jesse----------------------------------------------------<br>
----------------------------------------------------------2024----------------------------------------------------------<br>
--------------------------------------------------------------------------------------------------------------------------**


